```python
"""
Weather Visualizer - Production Flask Backend
A comprehensive weather application with personalization, entertainment, and alerts
"""

import os
import json
import random
import logging
from datetime import datetime, timedelta, timezone
from functools import wraps
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import base64
import hashlib
import time
from collections import defaultdict

import requests
from flask import Flask, request, jsonify, g
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import and_, or_, desc
from sqlalchemy.dialects.postgresql import JSON
from werkzeug.security import generate_password_hash, check_password_hash
import jwt

# Initialize Flask app
app = Flask(__name__)

# Configuration
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'postgresql://localhost/weather_visualizer')
if app.config['SQLALCHEMY_DATABASE_URI'].startswith('postgres://'):
    app.config['SQLALCHEMY_DATABASE_URI'] = app.config['SQLALCHEMY_DATABASE_URI'].replace('postgres://', 'postgresql://', 1)
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_size': 10,
    'pool_recycle': 3600,
    'pool_pre_ping': True,
}

# Initialize extensions
db = SQLAlchemy(app)
CORS(app, origins="*", supports_credentials=True)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Environment variables
OPENWEATHER_API_KEY = os.environ.get('OPENWEATHER_API_KEY')
SPOTIFY_CLIENT_ID = os.environ.get('SPOTIFY_CLIENT_ID')
SPOTIFY_CLIENT_SECRET = os.environ.get('SPOTIFY_CLIENT_SECRET')
IPINFO_TOKEN = os.environ.get('IPINFO_TOKEN', '')
FIREBASE_SERVER_KEY = os.environ.get('FIREBASE_SERVER_KEY', '')
ONESIGNAL_APP_ID = os.environ.get('ONESIGNAL_APP_ID', '')
ONESIGNAL_API_KEY = os.environ.get('ONESIGNAL_API_KEY', '')

# Rate limiting storage
rate_limit_storage = defaultdict(list)

# ======================= DATABASE MODELS =======================

class User(db.Model):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True, nullable=False)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(255))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_active = db.Column(db.DateTime, default=datetime.utcnow)
    streak_count = db.Column(db.Integer, default=0)
    last_streak_date = db.Column(db.Date)
    
    # Preferences
    preferences = db.Column(JSON, default=lambda: {
        'units': {'temp': 'celsius', 'speed': 'kmh'},
        'theme': 'light',
        'language': 'en',
        'favorite_locations': [],
        'weather_mood': 'neutral',
        'notifications_enabled': True,
        'alert_triggers': []
    })
    
    # Relations
    alerts = db.relationship('Alert', backref='user', lazy='dynamic', cascade='all, delete-orphan')
    logs = db.relationship('WeatherLog', backref='user', lazy='dynamic', cascade='all, delete-orphan')
    
    def update_streak(self):
        today = datetime.now(timezone.utc).date()
        if self.last_streak_date:
            if self.last_streak_date == today:
                return  # Already updated today
            elif self.last_streak_date == today - timedelta(days=1):
                self.streak_count += 1
            else:
                self.streak_count = 1
        else:
            self.streak_count = 1
        self.last_streak_date = today
        self.last_active = datetime.utcnow()

class Alert(db.Model):
    __tablename__ = 'alerts'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    type = db.Column(db.String(50))  # temp_drop, rain_start, wind_alert, etc.
    condition = db.Column(JSON)  # {'temp': '<15', 'wind': '>50', etc.}
    location = db.Column(db.String(100))
    enabled = db.Column(db.Boolean, default=True)
    last_triggered = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class WeatherLog(db.Model):
    __tablename__ = 'weather_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    location = db.Column(db.String(100))
    weather_data = db.Column(JSON)
    mood = db.Column(db.String(50))
    note = db.Column(db.Text)
    photo_url = db.Column(db.String(500))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

# ======================= HELPER FUNCTIONS =======================

def rate_limit(max_requests=60, window=60):
    """Rate limiting decorator"""
    def decorator(f):
        @wraps(f)
        def wrapped(*args, **kwargs):
            identifier = request.remote_addr
            now = time.time()
            
            # Clean old entries
            rate_limit_storage[identifier] = [
                timestamp for timestamp in rate_limit_storage[identifier]
                if now - timestamp < window
            ]
            
            if len(rate_limit_storage[identifier]) >= max_requests:
                return jsonify({'error': 'Rate limit exceeded'}), 429
            
            rate_limit_storage[identifier].append(now)
            return f(*args, **kwargs)
        return wrapped
    return decorator

def token_required(f):
    """JWT token authentication decorator"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            return jsonify({'error': 'Token missing'}), 401
        
        try:
            if token.startswith('Bearer '):
                token = token[7:]
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            g.current_user = User.query.get(data['user_id'])
            if not g.current_user:
                return jsonify({'error': 'Invalid token'}), 401
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'error': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    
    return decorated

def get_user_location():
    """Get user location from IP address"""
    try:
        ip = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ',' in ip:
            ip = ip.split(',')[0].strip()
        
        # Use ipinfo.io for location detection
        response = requests.get(f'https://ipinfo.io/{ip}/json?token={IPINFO_TOKEN}', timeout=5)
        if response.status_code == 200:
            data = response.json()
            if 'loc' in data:
                lat, lon = data['loc'].split(',')
                return {
                    'lat': float(lat),
                    'lon': float(lon),
                    'city': data.get('city', 'Unknown'),
                    'country': data.get('country', 'Unknown')
                }
    except Exception as e:
        logger.error(f"Location detection error: {e}")
    
    # Default to New York if detection fails
    return {'lat': 40.7128, 'lon': -74.0060, 'city': 'New York', 'country': 'US'}

def get_spotify_token():
    """Get Spotify access token using Client Credentials Flow"""
    try:
        auth_str = f"{SPOTIFY_CLIENT_ID}:{SPOTIFY_CLIENT_SECRET}"
        auth_bytes = auth_str.encode('utf-8')
        auth_base64 = base64.b64encode(auth_bytes).decode('utf-8')
        
        headers = {
            'Authorization': f'Basic {auth_base64}',
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        data = {'grant_type': 'client_credentials'}
        
        response = requests.post('https://accounts.spotify.com/api/token', 
                                headers=headers, data=data, timeout=10)
        
        if response.status_code == 200:
            return response.json().get('access_token')
    except Exception as e:
        logger.error(f"Spotify token error: {e}")
    return None

def get_weather_playlist(weather_condition):
    """Map weather conditions to Spotify playlists"""
    playlists = {
        'Clear': {'name': 'Sunny Vibes', 'query': 'happy summer hits'},
        'Clouds': {'name': 'Cloudy Day Chill', 'query': 'chill ambient cloudy'},
        'Rain': {'name': 'Rainy Day Lo-Fi', 'query': 'lofi rain study'},
        'Drizzle': {'name': 'Soft Rain Sounds', 'query': 'soft rain acoustic'},
        'Thunderstorm': {'name': 'Storm Energy', 'query': 'epic storm electronic'},
        'Snow': {'name': 'Winter Wonderland', 'query': 'cozy winter fireplace'},
        'Mist': {'name': 'Misty Morning', 'query': 'morning meditation ambient'},
        'Fog': {'name': 'Foggy Mystery', 'query': 'mysterious ambient fog'}
    }
    
    return playlists.get(weather_condition, {'name': 'Weather Mix', 'query': 'weather nature sounds'})

def get_weather_sounds(weather_condition):
    """Map weather conditions to background sound URLs"""
    sounds = {
        'Clear': 'https://cdn.pixabay.com/audio/2022/03/10/audio_c8c8a73467.mp3',  # Birds chirping
        'Clouds': 'https://cdn.pixabay.com/audio/2021/08/04/audio_12b0c7443c.mp3',  # Wind
        'Rain': 'https://cdn.pixabay.com/audio/2022/05/13/audio_257112ce99.mp3',  # Rain
        'Drizzle': 'https://cdn.pixabay.com/audio/2022/05/13/audio_257112ce99.mp3',  # Light rain
        'Thunderstorm': 'https://cdn.pixabay.com/audio/2021/08/04/audio_bb84e53e0e.mp3',  # Thunder
        'Snow': 'https://cdn.pixabay.com/audio/2022/11/21/audio_18e2de1e46.mp3',  # Fireplace
        'Mist': 'https://cdn.pixabay.com/audio/2024/02/09/audio_8568d5e164.mp3',  # Ocean waves
        'Fog': 'https://cdn.pixabay.com/audio/2024/02/09/audio_8568d5e164.mp3'  # Ambient
    }
    
    return sounds.get(weather_condition, sounds['Clear'])

def get_weather_activities(weather, temp):
    """Suggest activities based on weather conditions"""
    activities = []
    
    if weather == 'Clear' and temp > 20:
        activities = [
            "Perfect day for a picnic in the park! ðŸ§º",
            "Great weather for outdoor photography ðŸ“¸",
            "Ideal conditions for a bike ride ðŸš´",
            "Time for a refreshing walk in nature ðŸš¶",
            "Perfect for outdoor sports âš½"
        ]
    elif weather == 'Clear' and temp <= 20:
        activities = [
            "Cool and clear - perfect for a morning jog ðŸƒ",
            "Great day for hiking with a light jacket ðŸ¥¾",
            "Enjoy a warm coffee at an outdoor cafÃ© â˜•",
            "Visit a local farmer's market ðŸ›’"
        ]
    elif weather in ['Rain', 'Drizzle']:
        activities = [
            "Cozy up with a good book and hot chocolate ðŸ“šâ˜•",
            "Perfect movie marathon weather ðŸŽ¬",
            "Time for indoor yoga or meditation ðŸ§˜",
            "Great day for cooking a new recipe ðŸ‘¨â€ðŸ³",
            "Visit a museum or art gallery ðŸŽ¨"
        ]
    elif weather == 'Snow':
        activities = [
            "Build a snowman! â›„",
            "Perfect for skiing or snowboarding ðŸŽ¿",
            "Enjoy hot soup by the fireplace ðŸ²",
            "Time for winter photography â„ï¸ðŸ“¸",
            "Have a snowball fight! â„ï¸"
        ]
    elif weather == 'Clouds':
        activities = [
            "Great light for photography ðŸ“·",
            "Comfortable weather for a long walk ðŸš¶",
            "Perfect for outdoor reading ðŸ“–",
            "Visit a local cafÃ© â˜•",
            "Good day for gardening ðŸŒ±"
        ]
    else:
        activities = [
            "Check out a new podcast ðŸŽ§",
            "Organize your living space ðŸ ",
            "Call a friend you haven't talked to in a while ðŸ“ž",
            "Start a new hobby ðŸŽ¨",
            "Plan your next adventure ðŸ—ºï¸"
        ]
    
    return random.sample(activities, min(3, len(activities)))

def get_weather_fun_fact():
    """Return a random weather fun fact"""
    facts = [
        "The highest temperature ever recorded was 134Â°F (56.7Â°C) in Death Valley, California!",
        "A single lightning bolt can reach temperatures of 30,000Â°C - 5 times hotter than the sun's surface!",
        "The longest recorded heatwave lasted 160 days in Marble Bar, Australia (1923-1924).",
        "Raindrops aren't actually teardrop-shaped - they're more like hamburger buns!",
        "The world's largest snowflake was 15 inches wide and 8 inches thick!",
        "A cloud can weigh more than 1 million pounds!",
        "Lightning strikes the Earth about 100 times per second.",
        "The windiest place on Earth is Antarctica, with winds reaching 200 mph!",
        "It can be too cold to snow! Extremely cold air holds very little moisture.",
        "The smell of rain has a name - 'Petrichor'!",
        "Hurricanes in the Southern Hemisphere spin clockwise, opposite to Northern ones.",
        "The coldest temperature ever recorded was -128.6Â°F (-89.2Â°C) in Antarctica.",
        "A rainbow can only be seen in the morning or late afternoon.",
        "Ball lightning is a rare phenomenon that scientists still can't fully explain!",
        "The fastest wind speed ever recorded was 318 mph during a tornado in Oklahoma.",
        "Weather forecasting dates back to 650 BC in Babylon!",
        "Mammatus clouds look like bubble wrap in the sky!",
        "A 'moonbow' is a rainbow that occurs at night!",
        "Snowflakes can take up to 1 hour to fall from cloud to ground.",
        "The weather on Mount Washington changes every 15 minutes on average!"
    ]
    
    return random.choice(facts)

def get_personalized_greeting(user, weather, temp):
    """Generate personalized greeting based on time and weather"""
    hour = datetime.now().hour
    name = user.username if user else "Friend"
    
    if 5 <= hour < 12:
        time_greeting = "Good morning"
    elif 12 <= hour < 17:
        time_greeting = "Good afternoon"
    elif 17 <= hour < 21:
        time_greeting = "Good evening"
    else:
        time_greeting = "Good night"
    
    weather_comment = ""
    if weather == "Clear" and temp > 25:
        weather_comment = "It's a beautiful sunny day!"
    elif weather == "Rain":
        weather_comment = "Don't forget your umbrella!"
    elif weather == "Snow":
        weather_comment = "Bundle up, it's snowy!"
    elif temp < 10:
        weather_comment = "It's quite chilly today!"
    elif temp > 30:
        weather_comment = "Stay hydrated in this heat!"
    
    return f"{time_greeting}, {name}! {weather_comment}"

def send_push_notification(user_id, title, message):
    """Send push notification via Firebase or OneSignal"""
    try:
        if FIREBASE_SERVER_KEY:
            # Firebase implementation
            headers = {
                'Authorization': f'key={FIREBASE_SERVER_KEY}',
                'Content-Type': 'application/json'
            }
            
            data = {
                'to': f'/topics/user_{user_id}',
                'notification': {
                    'title': title,
                    'body': message,
                    'icon': 'weather-icon'
                }
            }
            
            requests.post('https://fcm.googleapis.com/fcm/send', 
                         json=data, headers=headers, timeout=5)
        
        elif ONESIGNAL_APP_ID and ONESIGNAL_API_KEY:
            # OneSignal implementation
            headers = {
                'Authorization': f'Basic {ONESIGNAL_API_KEY}',
                'Content-Type': 'application/json'
            }
            
            data = {
                'app_id': ONESIGNAL_APP_ID,
                'include_external_user_ids': [str(user_id)],
                'contents': {'en': message},
                'headings': {'en': title}
            }
            
            requests.post('https://onesignal.com/api/v1/notifications',
                         json=data, headers=headers, timeout=5)
    except Exception as e:
        logger.error(f"Push notification error: {e}")

def check_alert_triggers(user, weather_data):
    """Check if any user alerts should be triggered"""
    if not user or not user.preferences.get('notifications_enabled'):
        return
    
    alerts = Alert.query.filter_by(user_id=user.id, enabled=True).all()
    
    for alert in alerts:
        should_trigger = False
        message = ""
        
        if alert.type == 'temp_drop' and 'temp' in alert.condition:
            threshold = alert.condition['temp']
            current_temp = weather_data.get('main', {}).get('temp', 999)
            if current_temp < threshold:
                should_trigger = True
                message = f"Temperature dropped below {threshold}Â°C in {alert.location}"
        
        elif alert.type == 'rain_start':
            if weather_data.get('weather', [{}])[0].get('main') in ['Rain', 'Drizzle']:
                should_trigger = True
                message = f"It's starting to rain in {alert.location}"
        
        elif alert.type == 'wind_alert' and 'wind' in alert.condition:
            threshold = alert.condition['wind']
            current_wind = weather_data.get('wind', {}).get('speed', 0)
            if current_wind > threshold:
                should_trigger = True
                message = f"Strong winds ({current_wind} km/h) in {alert.location}"
        
        if should_trigger:
            # Check if not recently triggered (within last hour)
            if alert.last_triggered:
                time_diff = datetime.utcnow() - alert.last_triggered
                if time_diff.total_seconds() < 3600:
                    continue
            
            alert.last_triggered = datetime.utcnow()
            db.session.commit()
            
            send_push_notification(user.id, "Weather Alert", message)

def convert_units(data, units):
    """Convert weather data to specified units"""
    if units.get('temp') == 'fahrenheit':
        if 'temp' in data:
            data['temp'] = data['temp'] * 9/5 + 32
        if 'feels_like' in data:
            data['feels_like'] = data['feels_like'] * 9/5 + 32
    
    if units.get('speed') == 'mph':
        if 'speed' in data:
            data['speed'] = data['speed'] * 0.621371
    
    return data

# ======================= API ENDPOINTS =======================

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat(),
        'version': '1.0.0'
    })

@app.route('/api/auth/register', methods=['POST'])
@rate_limit(max_requests=5, window=300)
def register():
    """User registration"""
    try:
        data = request.json
        email = data.get('email')
        username = data.get('username')
        password = data.get('password')
        
        if not all([email, username, password]):
            return jsonify({'error': 'Missing required fields'}), 400
        
        if User.query.filter_by(email=email).first():
            return jsonify({'error': 'Email already exists'}), 400
        
        if User.query.filter_by(username=username).first():
            return jsonify({'error': 'Username already exists'}), 400
        
        user = User(
            email=email,
            username=username,
            password_hash=generate_password_hash(password)
        )
        
        db.session.add(user)
        db.session.commit()
        
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(days=30)
        }, app.config['SECRET_KEY'], algorithm='HS256')
        
        return jsonify({
            'message': 'Registration successful',
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email
            }
        }), 201
        
    except Exception as e:
        logger.error(f"Registration error: {e}")
        return jsonify({'error': 'Registration failed'}), 500

@app.route('/api/auth/login', methods=['POST'])
@rate_limit(max_requests=10, window=300)
def login():
    """User login"""
    try:
        data = request.json
        email = data.get('email')
        password = data.get('password')
        
        if not all([email, password]):
            return jsonify({'error': 'Missing credentials'}), 400
        
        user = User.query.filter_by(email=email).first()
        
        if not user or not check_password_hash(user.password_hash, password):
            return jsonify({'error': 'Invalid credentials'}), 401
        
        user.update_streak()
        db.session.commit()
        
        token = jwt.encode({
            'user_id': user.id,
            'exp': datetime.utcnow() + timedelta(days=30)
        }, app.config['SECRET_KEY'], algorithm='HS256')
        
        return jsonify({
            'message': 'Login successful',
            'token': token,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'streak': user.streak_count,
                'preferences': user.preferences
            }
        }), 200
        
    except Exception as e:
        logger.error(f"Login error: {e}")
        return jsonify({'error': 'Login failed'}), 500

@app.route('/api/weather/current', methods=['GET'])
@rate_limit(max_requests=60, window=60)
def get_current_weather():
    """Get current weather with automatic location detection"""
    try:
        # Check for manual location parameters
        lat = request.args.get('lat')
        lon = request.args.get('lon')
        city = request.args.get('city')
        
        # Get user preferences if authenticated
        user = None
        token = request.headers.get('Authorization')
        if token:
            try:
                if token.startswith('Bearer '):
                    token = token[7:]
                data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
                user = User.query.get(data['user_id'])
            except:
                pass
        
        # Determine location
        if lat and lon:
            url = f"https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}"
            location_name = f"{lat},{lon}"
        elif city:
            url = f"https://api.openweathermap.org/data/2.5/weather?q={city}"
            location_name = city
        else:
            # Auto-detect location
            location = get_user_location()
            url = f"https://api.openweathermap.org/data/2.5/weather?lat={location['lat']}&lon={location['lon']}"
            location_name = location['city']
        
        # Fetch weather data
        url += f"&appid={OPENWEATHER_API_KEY}&units=metric"
        response = requests.get(url, timeout=10)
        
        if response.status_code != 200:
            return jsonify({'error': 'Weather data unavailable'}), 503
        
        weather_data = response.json()
        
        # Apply unit conversion if user has preferences
        if user and user.preferences:
            units = user.preferences.get('units', {})
            weather_data['main'] = convert_units(weather_data['main'], units)
            if 'wind' in weather_data:
                weather_data['wind'] = convert_units(weather_data['wind'], units)
        
        # Get additional data
        weather_condition = weather_data['weather'][0]['main']
        temp = weather_data['main']['temp']
        
        # Get personalized greeting
        greeting = get_personalized_greeting(user, weather_condition, temp)
        
        # Get activities
        activities = get_weather_activities(weather_condition, temp)
        
        # Get background sound
        sound_url = get_weather_sounds(weather_condition)
        
        # Check alert triggers
        if user:
            check_alert_triggers(user, weather_data)
        
        # Log weather check if user is authenticated
        if user:
            log = WeatherLog(
                user_id=user.id,
                location=location_name,
                weather_data=weather_data
            )
            db.session.add(log)
            db.session.commit()
        
        return jsonify({
            'location': location_name,
            'weather': weather_data,
            'greeting': greeting,
            'activities': activities,
            'sound_url': sound_url,
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Weather fetch error: {e}")
        return jsonify({'error': 'Failed to fetch weather data'}), 500

@app.route('/api/weather/forecast', methods=['GET'])
@rate_limit(max_requests=30, window=60)
def get_forecast():
    """Get 7-day weather forecast with hourly breakdown"""
    try:
        lat = request.args.get('lat')
        lon = request.args.get('lon')
        city = request.args.get('city')
        include_hourly = request.args.get('hourly', 'false').lower() == 'true'
        
        if lat and lon:
            # One Call API for detailed forecast
            url = f"https://api.openweathermap.org/data/3.0/onecall?lat={lat}&lon={lon}"
            url += f"&exclude=minutely,alerts&appid={OPENWEATHER_API_KEY}&units=metric"
        elif city:
            # First get coordinates for the city
            geo_url = f"https://api.openweathermap.org/geo/1.0/direct?q={city}&limit=1&appid={OPENWEATHER_API_KEY}"
            geo_response = requests.get(geo_url, timeout=10)
            if geo_response.status_code == 200 and geo_response.json():
                geo_data = geo_response.json()[0]
                lat, lon = geo_data['lat'], geo_data['lon']
                url = f"https://api.openweathermap.org/data/3.0/onecall?lat={lat}&lon={lon}"
                url += f"&exclude=minutely,alerts&appid={OPENWEATHER_API_KEY}&units=metric"
            else:
                # Fallback to 5-day forecast
                url = f"https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={OPENWEATHER_API_KEY}&units=metric"
        else:
            # Auto-detect location
            location = get_user_location()
            url = f"https://api.openweathermap.org/data/3.0/onecall?lat={location['lat']}&lon={location['lon']}"
            url += f"&exclude=minutely,alerts&appid={OPENWEATHER_API_KEY}&units=metric"
        
        response = requests.get(url, timeout=10)
        
        if response.status_code != 200:
            # Fallback to 5-day forecast API
            if city:
                url = f"https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={OPENWEATHER_API_KEY}&units=metric"
            else:
                location = get_user_location()
                url = f"https://api.openweathermap.org/data/2.5/forecast?lat={location['lat']}&lon={location['lon']}&appid={OPENWEATHER_API_KEY}&units=metric"
            
            response = requests.get(url, timeout=10)
        
        if response.status_code != 200:
            return jsonify({'error': 'Forecast data unavailable'}), 503
        
        forecast_data = response.json()
        
        # Format response based on API version
        if 'daily' in forecast_data:
            # One Call API response
            result = {
                'daily': forecast_data['daily'][:7],
                'current': forecast_data.get('current', {}),
                'timezone': forecast_data.get('timezone', 'UTC')
            }
            if include_hourly:
                result['hourly'] = forecast_data.get('hourly', [])[:48]
        else:
            # 5-day forecast API response
            result = {
                'list': forecast_data['list'],
                'city': forecast_data.get('city', {})
            }
        
        return jsonify(result), 200
        
    except Exception as e:
        logger.error(f"Forecast fetch error: {e}")
        return jsonify({'error': 'Failed to fetch forecast data'}), 500

@app.route('/api/weather/historical', methods=['GET'])
@token_required
@rate_limit(max_requests=10, window=60)
def get_historical_weather():
    """Get historical weather data (past 7-30 days)"""
    try:
        lat = request.args.get('lat', type=float)
        lon = request.args.get('lon', type=float)
        days = request.args.get('days', 7, type=int)
        
        if not lat or not lon:
            return jsonify({'error': 'Latitude and longitude required'}), 400
        
        if days < 1 or days > 30:
            return jsonify({'error': 'Days must be between 1 and 30'}), 400
        
        historical_data = []
        
        for i in range(1, days + 1):
            dt = int((datetime.utcnow() - timedelta(days=i)).timestamp())
            url = f"https://api.openweathermap.org/data/3.0/onecall/timemachine"
            url += f"?lat={lat}&lon={lon}&dt={dt}&appid={OPENWEATHER_API_KEY}&units=metric"
            
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                historical_data.append(response.json())
        
        return jsonify({
            'historical': historical_data,
            'days': days,
            'location': {'lat': lat, 'lon': lon}
        }), 200
        
    except Exception as e:
        logger.error(f"Historical weather error: {e}")
        return jsonify({'error': 'Failed to fetch historical data'}), 500

@app.route('/api/weather/alerts', methods=['GET'])
@rate_limit(max_requests=30, window=60)
def get_weather_alerts():
    """Get severe weather alerts for a location"""
    try:
        lat = request.args.get('lat')
        lon = request.args.get('lon')
        
        if not lat or not lon:
            location = get_user_location()
            lat, lon = location['lat'], location['lon']
        
        # One Call API includes alerts
        url = f"https://api.openweathermap.org/data/3.0/onecall?lat={lat}&lon={lon}"
        url += f"&exclude=minutely,current,hourly,daily&appid={OPENWEATHER_API_KEY}"
        
        response = requests.get(url, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            alerts = data.get('alerts', [])
            
            # Format alerts
            formatted_alerts = []
            for alert in alerts:
                formatted_alerts.append({
                    'sender': alert.get('sender_name', 'Weather Service'),
                    'event': alert.get('event', 'Weather Alert'),
                    'start': datetime.fromtimestamp(alert.get('start', 0)).isoformat(),
                    'end': datetime.fromtimestamp(alert.get('end', 0)).isoformat(),
                    'description': alert.get('description', ''),
                    'tags': alert.get('tags', [])
                })
            
            return jsonify({
                'alerts': formatted_alerts,
                'location': {'lat': lat, 'lon': lon},
                'timestamp': datetime.utcnow().isoformat()
            }), 200
        
        return jsonify({'alerts': [], 'message': 'No alerts available'}), 200
        
    except Exception as e:
        logger.error(f"Weather alerts error: {e}")
        return jsonify({'error': 'Failed to fetch alerts'}), 500

@app.route('/api/weather/global-random', methods=['GET'])
@rate_limit(max_requests=30, window=60)
def get_random_global_weather():
    """Get weather from a random global city"""
    try:
        cities = [
            {'name': 'Tokyo', 'country': 'JP'},
            {'name': 'Paris', 'country': 'FR'},
            {'name': 'Sydney', 'country': 'AU'},
            {'name': 'Cairo', 'country': 'EG'},
            {'name': 'Moscow', 'country': 'RU'},
            {'name': 'Rio de Janeiro', 'country': 'BR'},
            {'name': 'Mumbai', 'country': 'IN'},
            {'name': 'Cape Town', 'country': 'ZA'},
            {'name': 'Dubai', 'country': 'AE'},
            {'name': 'Reykjavik', 'country': 'IS'},
            {'name': 'Bangkok', 'country': 'TH'},
            {'name': 'Mexico City', 'country': 'MX'},
            {'name': 'Stockholm', 'country': 'SE'},
            {'name': 'Seoul', 'country': 'KR'},
            {'name': 'Buenos Aires', 'country': 'AR'},
            {'name': 'Singapore', 'country': 'SG'},
            {'name': 'Toronto', 'country': 'CA'},
            {'name': 'Berlin', 'country': 'DE'},
            {'name': 'Rome', 'country': 'IT'},
            {'name': 'Amsterdam', 'country': 'NL'}
        ]
        
        city = random.choice(cities)
        
        url = f"https://api.openweathermap.org/data/2.5/weather?q={city['name']},{city['country']}"
        url += f"&appid={OPENWEATHER_API_KEY}&units=metric"
        
        response = requests.get(url, timeout=10)
        
        if response.status_code == 200:
            weather_data = response.json()
            
            # Add interesting fact about the city
            city_facts = {
                'Tokyo': 'The world\'s most populous metropolitan area!',
                'Paris': 'The City of Light averages 1,662 hours of sunshine per year.',
                'Sydney': 'Home to the world-famous Opera House and Harbour Bridge!',
                'Cairo': 'One of the hottest cities in the world during summer.',
                'Moscow': 'Can experience temperatures below -25Â°C in winter!',
                'Rio de Janeiro': 'Famous for its carnival and beautiful beaches.',
                'Mumbai': 'Experiences heavy monsoon rains from June to September.',
                'Cape Town': 'Has a Mediterranean climate with dry summers.',
                'Dubai': 'One of the world\'s hottest cities with summer temps over 45Â°C!',
                'Reykjavik': 'The world\'s northernmost capital city.',
                'Bangkok': 'Known as one of the hottest cities year-round.',
                'Mexico City': 'At 2,250m elevation, it has mild temperatures year-round.',
                'Stockholm': 'Built on 14 islands connected by 57 bridges!',
                'Seoul': 'Experiences four distinct seasons.',
                'Buenos Aires': 'Has a humid subtropical climate.',
                'Singapore': 'Tropical climate with high humidity year-round.',
                'Toronto': 'Can have temperature swings of 30Â°C between seasons!',
                'Berlin': 'Continental climate with warm summers and cold winters.',
                'Rome': 'Enjoys a Mediterranean climate with hot, dry summers.',
                'Amsterdam': 'Known for its rainy weather and cycling culture!'
            }
            
            return jsonify({
                'city': city,
                'weather': weather_data,
                'fact': city_facts.get(city['name'], 'A fascinating city with unique weather!'),
                'timestamp': datetime.utcnow().isoformat()
            }), 200
        
        return jsonify({'error': 'Failed to fetch global weather'}), 503
        
    except Exception as e:
        logger.error(f"Global weather error: {e}")
        return jsonify({'error': 'Failed to fetch global weather'}), 500

@app.route('/api/user/preferences', methods=['GET', 'PUT'])
@token_required
def user_preferences():
    """Get or update user preferences"""
    try:
        user = g.current_user
        
        if request.method == 'GET':
            return jsonify({
                'preferences': user.preferences,
                'streak': user.streak_count,
                'last_active': user.last_active.isoformat() if user.last_active else None
            }), 200
        
        elif request.method == 'PUT':
            data = request.json
            
            # Update preferences
            if 'units' in data:
                user.preferences['units'] = data['units']
            if 'theme' in data:
                user.preferences['theme'] = data['theme']
            if 'language' in data:
                user.preferences['language'] = data['language']
            if 'favorite_locations' in data:
                user.preferences['favorite_locations'] = data['favorite_locations']
            if 'weather_mood' in data:
                user.preferences['weather_mood'] = data['weather_mood']
            if 'notifications_enabled' in data:
                user.preferences['notifications_enabled'] = data['notifications_enabled']
            if 'alert_triggers' in data:
                user.preferences['alert_triggers'] = data['alert_triggers']
            
            db.session.commit()
            
            return jsonify({
                'message': 'Preferences updated',
                'preferences': user.preferences
            }), 200
            
    except Exception as e:
        logger.error(f"Preferences error: {e}")
        return jsonify({'error': 'Failed to handle preferences'}), 500

@app.route('/api/user/alerts', methods=['GET', 'POST', 'PUT', 'DELETE'])
@token_required
def manage_alerts():
    """Manage user weather alerts"""
    try:
        user = g.current_user
        
        if request.method == 'GET':
            alerts = Alert.query.filter_by(user_id=user.id).all()
            return jsonify({
                'alerts': [{
                    'id': a.id,
                    'type': a.type,
                    'condition': a.condition,
                    'location': a.location,
                    'enabled': a.enabled,
                    'last_triggered': a.last_triggered.isoformat() if a.last_triggered else None
                } for a in alerts]
            }), 200
        
        elif request.method == 'POST':
            data = request.json
            alert = Alert(
                user_id=user.id,
                type=data.get('type'),
                condition=data.get('condition', {}),
                location=data.get('location', 'Current Location'),
                enabled=data.get('enabled', True)
            )
            db.session.add(alert)
            db.session.commit()
            
            return jsonify({
                'message': 'Alert created',
                'alert_id': alert.id
            }), 201
        
        elif request.method == 'PUT':
            alert_id = request.json.get('alert_id')
            alert = Alert.query.filter_by(id=alert_id, user_id=user.id).first()
            
            if not alert:
                return jsonify({'error': 'Alert not found'}), 404
            
            data = request.json
            if 'enabled' in data:
                alert.enabled = data['enabled']
            if 'condition' in data:
                alert.condition = data['condition']
            if 'location' in data:
                alert.location = data['location']
            
            db.session.commit()
            return jsonify({'message': 'Alert updated'}), 200
        
        elif request.method == 'DELETE':
            alert_id = request.args.get('alert_id')
            alert = Alert.query.filter_by(id=alert_id, user_id=user.id).first()
            
            if not alert:
                return jsonify({'error': 'Alert not found'}), 404
            
            db.session.delete(alert)
            db.session.commit()
            return jsonify({'message': 'Alert deleted'}), 200
            
    except Exception as e:
        logger.error(f"Alert management error: {e}")
        return jsonify({'error': 'Failed to manage alerts'}), 500

@app.route('/api/user/logs', methods=['GET', 'POST'])
@token_required
def weather_logs():
    """Get or create weather logs/journal entries"""
    try:
        user = g.current_user
        
        if request.method == 'GET':
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 10, type=int)
            
            logs = WeatherLog.query.filter_by(user_id=user.id)\
                .order_by(WeatherLog.created_at.desc())\
                .paginate(page=page, per_page=per_page, error_out=False)
            
            return jsonify({
                'logs': [{
                    'id': log.id,
                    'location': log.location,
                    'weather_data': log.weather_data,
                    'mood': log.mood,
                    'note': log.note,
                    'photo_url': log.photo_url,
                    'created_at': log.created_at.isoformat()
                } for log in logs.items],
                'total': logs.total,
                'pages': logs.pages,
                'current_page': page
            }), 200
        
        elif request.method == 'POST':
            data = request.json
            log = WeatherLog(
                user_id=user.id,
                location=data.get('location'),
                weather_data=data.get('weather_data', {}),
                mood=data.get('mood'),
                note=data.get('note'),
                photo_url=data.get('photo_url')
            )
            db.session.add(log)
            db.session.commit()
            
            return jsonify({
                'message': 'Log created',
                'log_id': log.id
            }), 201
            
    except Exception as e:
        logger.error(f"Weather logs error: {e}")
        return jsonify({'error': 'Failed to manage logs'}), 500

@app.route('/api/entertainment/fun-fact', methods=['GET'])
@rate_limit(max_requests=30, window=60)
def get_fun_fact():
    """Get daily weather fun fact"""
    try:
        fact = get_weather_fun_fact()
        return jsonify({
            'fact': fact,
            'timestamp': datetime.utcnow().isoformat()
        }), 200
    except Exception as e:
        logger.error(f"Fun fact error: {e}")
        return jsonify({'error': 'Failed to get fun fact'}), 500

@app.route('/api/entertainment/activities', methods=['GET'])
@rate_limit(max_requests=30, window=60)
def get_activities():
    """Get activity suggestions based on current weather"""
    try:
        # Get weather data
        lat = request.args.get('lat')
        lon = request.args.get('lon')
        city = request.args.get('city')
        
        if lat and lon:
            url = f"https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}"
        elif city:
            url = f"https://api.openweathermap.org/data/2.5/weather?q={city}"
        else:
            location = get_user_location()
            url = f"https://api.openweathermap.org/data/2.5/weather?lat={location['lat']}&lon={location['lon']}"
        
        url += f"&appid={OPENWEATHER_API_KEY}&units=metric"
        response = requests.get(url, timeout=10)
        
        if response.status_code == 200:
            weather_data = response.json()
            weather_condition = weather_data['weather'][0]['main']
            temp = weather_data['main']['temp']
            
            activities = get_weather_activities(weather_condition, temp)
            
            return jsonify({
                'activities': activities,
                'weather': weather_condition,
                'temperature': temp,
                'timestamp': datetime.utcnow().isoformat()
            }), 200
        
        return jsonify({'error': 'Failed to get weather for activities'}), 503
        
    except Exception as e:
        logger.error(f"Activities error: {e}")
        return jsonify({'error': 'Failed to get activities'}), 500

@app.route('/api/entertainment/spotify-playlist', methods=['GET'])
@rate_limit(max_requests=20, window=60)
def get_spotify_playlist():
    """Get Spotify playlist based on weather"""
    try:
        if not SPOTIFY_CLIENT_ID or not SPOTIFY_CLIENT_SECRET:
            return jsonify({'error': 'Spotify integration not configured'}), 503
        
        # Get weather data
        weather_condition = request.args.get('weather', 'Clear')
        
        # Get Spotify token
        token = get_spotify_token()
        if not token:
            return jsonify({'error': 'Failed to authenticate with Spotify'}), 503
        
        # Get playlist for weather
        playlist_info = get_weather_playlist(weather_condition)
        
        # Search for playlists
        headers = {'Authorization': f'Bearer {token}'}
        search_url = f"https://api.spotify.com/v1/search?q={playlist_info['query']}&type=playlist&limit=5"
        
        response = requests.get(search_url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            playlists = data.get('playlists', {}).get('items', [])
            
            formatted_playlists = []
            for playlist in playlists:
                formatted_playlists.append({
                    'id': playlist['id'],
                    'name': playlist['name'],
                    'description': playlist.get('description', ''),
                    'url': playlist['external_urls']['spotify'],
                    'image': playlist['images'][0]['url'] if playlist.get('images') else None,
                    'tracks_total': playlist['tracks']['total']
                })
            
            return jsonify({
                'weather': weather_condition,
                'theme': playlist_info['name'],
                'playlists': formatted_playlists
            }), 200
        
        return jsonify({'error': 'Failed to fetch playlists'}), 503
        
    except Exception as e:
        logger.error(f"Spotify playlist error: {e}")
        return jsonify({'error': 'Failed to get playlist'}), 500

@app.route('/api/entertainment/background-sounds', methods=['GET'])
@rate_limit(max_requests=30, window=60)
def get_background_sounds():
    """Get background sound URLs based on weather"""
    try:
        weather_condition = request.args.get('weather', 'Clear')
        sound_url = get_weather_sounds(weather_condition)
        
        # Additional sound variations
        all_sounds = {
            'Clear': [
                {'name': 'Birds Chirping', 'url': sound_url},
                {'name': 'Beach Waves', 'url': 'https://cdn.pixabay.com/audio/2022/06/07/audio_d963871e0b.mp3'},
                {'name': 'Forest Ambience', 'url': 'https://cdn.pixabay.com/audio/2022/03/10/audio_6ba5e7b591.mp3'}
            ],
            'Rain': [
                {'name': 'Rain on Window', 'url': sound_url},
                {'name': 'Soft Rain', 'url': 'https://cdn.pixabay.com/audio/2022/05/13/audio_1f94ff8fb8.mp3'},
                {'name': 'Rain with Thunder', 'url': 'https://cdn.pixabay.com/audio/2021/08/04/audio_bb84e53e0e.mp3'}
            ],
            'Snow': [
                {'name': 'Fireplace Crackling', 'url': sound_url},
                {'name': 'Winter Wind', 'url': 'https://cdn.pixabay.com/audio/2021/08/04/audio_12b0c7443c.mp3'},
                {'name': 'Cozy Cabin', 'url': 'https://cdn.pixabay.com/audio/2022/11/21/audio_c0cccb4c6f.mp3'}
            ],
            'Thunderstorm': [
                {'name': 'Thunder Storm', 'url': sound_url},
                {'name': 'Distant Thunder', 'url': 'https://cdn.pixabay.com/audio/2022/08/25/audio_cbf4d43ec8.mp3'},
                {'name': 'Heavy Rain', 'url': 'https://cdn.pixabay.com/audio/2022/05/13/audio_257112ce99.mp3'}
            ]
        }
        
        sounds = all_sounds.get(weather_condition, all_sounds['Clear'])
        
        return jsonify({
            'weather': weather_condition,
            'sounds': sounds,
            'primary_sound': sound_url
        }), 200
        
    except Exception as e:
        logger.error(f"Background sounds error: {e}")
        return jsonify({'error': 'Failed to get sounds'}), 500

@app.route('/api/stats/streak', methods=['GET'])
@token_required
def get_streak():
    """Get user's daily streak"""
    try:
        user = g.current_user
        user.update_streak()
        db.session.commit()
        
        return jsonify({
            'streak': user.streak_count,
            'last_active': user.last_active.isoformat() if user.last_active else None,
            'badges': []  # Can be expanded with achievement system
        }), 200
        
    except Exception as e:
        logger.error(f"Streak error: {e}")
        return jsonify({'error': 'Failed to get streak'}), 500

@app.route('/api/travel/recommendations', methods=['GET'])
@rate_limit(max_requests=20, window=60)
def get_travel_recommendations():
    """Get travel recommendations based on weather preferences"""
    try:
        preference = request.args.get('preference', 'sunny')  # sunny, cold, mild, tropical
        
        recommendations = {
            'sunny': [
                {'city': 'Barcelona', 'country': 'Spain', 'reason': 'Mediterranean sunshine and beaches'},
                {'city': 'San Diego', 'country': 'USA', 'reason': 'Year-round perfect weather'},
                {'city': 'Perth', 'country': 'Australia', 'reason': 'Sunny days and beautiful beaches'},
                {'city': 'Tel Aviv', 'country': 'Israel', 'reason': 'Mediterranean climate with 300+ sunny days'},
                {'city': 'Cape Town', 'country': 'South Africa', 'reason': 'Stunning scenery with great weather'}
            ],
            'cold': [
                {'city': 'Reykjavik', 'country': 'Iceland', 'reason': 'Northern lights and winter wonders'},
                {'city': 'Helsinki', 'country': 'Finland', 'reason': 'Winter activities and cozy culture'},
                {'city': 'Quebec City', 'country': 'Canada', 'reason': 'Winter carnival and French charm'},
                {'city': 'TromsÃ¸', 'country': 'Norway', 'reason': 'Arctic adventures and midnight sun'},
                {'city': 'Sapporo', 'country': 'Japan', 'reason': 'Snow festival and winter sports'}
            ],
            'mild': [
                {'city': 'San Francisco', 'country': 'USA', 'reason': 'Cool summers and mild winters'},
                {'city': 'Edinburgh', 'country': 'Scotland', 'reason': 'Temperate climate with historic charm'},
                {'city': 'Vancouver', 'country': 'Canada', 'reason': 'Mild coastal climate year-round'},
                {'city': 'Auckland', 'country': 'New Zealand', 'reason': 'Oceanic climate with mild seasons'},
                {'city': 'Portland', 'country': 'USA', 'reason': 'Mild temperatures and nature access'}
            ],
            'tropical': [
                {'city': 'Bali', 'country': 'Indonesia', 'reason': 'Tropical paradise with warm weather'},
                {'city': 'Phuket', 'country': 'Thailand', 'reason': 'Beach resorts and tropical climate'},
                {'city': 'Maldives', 'country': 'Maldives', 'reason': 'Island paradise with perfect weather'},
                {'city': 'Cancun', 'country': 'Mexico', 'reason': 'Caribbean beaches and Mayan culture'},
                {'city': 'Maui', 'country': 'USA', 'reason': 'Hawaiian paradise with year-round warmth'}
            ]
        }
        
        selected = recommendations.get(preference, recommendations['sunny'])
        
        # Get current weather for top 3 recommendations
        weather_data = []
        for dest in selected[:3]:
            try:
                url = f"https://api.openweathermap.org/data/2.5/weather?q={dest['city']},{dest['country']}"
                url += f"&appid={OPENWEATHER_API_KEY}&units=metric"
                response = requests.get(url, timeout=5)
                if response.status_code == 200:
                    data = response.json()
                    dest['current_weather'] = {
                        'temp': data['main']['temp'],
                        'description': data['weather'][0]['description'],
                        'icon': data['weather'][0]['icon']
                    }
            except:
                pass
            weather_data.append(dest)
        
        return jsonify({
            'preference': preference,
            'recommendations': weather_data + selected[3:],
            'timestamp': datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"Travel recommendations error: {e}")
        return jsonify({'error': 'Failed to get recommendations'}), 500

# ======================= DATABASE INITIALIZATION =======================

@app.before_first_request
def create_tables():
    """Create database tables if they don't exist"""
    try:
        db.create_all()
        logger.info("Database tables created successfully")
    except Exception as e:
        logger.error(f"Database initialization error: {e}")

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return jsonify({'error': 'Internal server error'}), 500

# ======================= MAIN =======================

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    
    logger.info(f"Starting Weather Visualizer Backend on port {port}")
    logger.info(f"Debug mode: {debug}")
    
    # Check required environment variables
    if not OPENWEATHER_API_KEY:
        logger.warning("OPENWEATHER_API_KEY not set - weather features will not work")
    if not SPOTIFY_CLIENT_ID or not SPOTIFY_CLIENT_SECRET:
        logger.warning("Spotify credentials not set - music features will not work")
    
    app.run(host='0.0.0.0', port=port, debug=debug)
```

This production-grade Flask backend provides:

## **Core Features:**
1. âœ… **Automatic location detection** via IP geolocation
2. âœ… **Current weather & 7-day forecast** with hourly breakdown
3. âœ… **User authentication** with JWT tokens
4. âœ… **PostgreSQL integration** for user data, preferences, logs
5. âœ… **Weather alerts** (custom triggers & severe weather)
6. âœ… **Spotify integration** with weather-matched playlists
7. âœ… **Background sounds** mapped to weather conditions
8. âœ… **Daily weather fun facts** and activity suggestions
9. âœ… **Global random city weather** explorer
10. âœ… **Historical weather data** (past 7-30 days)
11. âœ… **Travel recommendations** based on weather preferences
12. âœ… **User streaks** and engagement tracking
13. âœ… **Weather journaling** with mood tracking
14. âœ… **Multi-unit support** (Â°C/Â°F, km/h/mph)
15. âœ… **Rate limiting** to prevent abuse
16. âœ… **Push notifications** support (Firebase/OneSignal)
17. âœ… **Personalized greetings** based on time & weather

## **Environment Variables Required:**
```bash
# Required
SECRET_KEY=your-secret-key-here
DATABASE_URL=postgresql://user:pass@host/dbname
OPENWEATHER_API_KEY=your-openweather-api-key

# Spotify Integration
SPOTIFY_CLIENT_ID=your-spotify-client-id
SPOTIFY_CLIENT_SECRET=your-spotify-client-secret

# Optional
IPINFO_TOKEN=your-ipinfo-token
FIREBASE_SERVER_KEY=your-firebase-key
ONESIGNAL_APP_ID=your-onesignal-app-id
ONESIGNAL_API_KEY=your-onesignal-api-key
```

## **Key Endpoints:**
- `GET /api/weather/current` - Auto-detect location weather
- `GET /api/weather/forecast` - 7-day forecast
- `GET /api/weather/alerts` - Severe weather alerts
- `GET /api/entertainment/spotify-playlist` - Weather-based playlists
- `GET /api/entertainment/background-sounds` - Ambient sounds
- `POST /api/auth/register` - User registration
- `GET /api/user/preferences` - User settings
- `POST /api/user/alerts` - Create custom alerts

## **Deployment Ready:**
- Single file architecture for simplicity
- PostgreSQL with SQLAlchemy ORM
- Flask-CORS for frontend integration
- Environment-based configuration
- Production logging
- Error handling
- Scalable for Render deployment

The backend is fully production-ready and can be deployed directly to Render with proper environment variables configured.